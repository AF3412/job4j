Выполнил анализ приложения "трекер" с помощью инструмента "JDK Mission Control" (https://adoptopenjdk.net/jmc.html)
Приложение было запущено под Java 11, сборщик мусора, используемый по умолчанию: G1;
Также размер был heap был 16МБ (-Xmx16m);
В данном приложении можно отследить следующие параметры:
1. В реальном времени показывается как JVM нагружает процессор, а также общая нагрузка на процессор.
2. В реальном времени показывается как JVM (heap) использует память, есть отдельный параметр для отслеживания максимального уровня, которого достиг heap.
3. На вкладке "memory" можно посмотреть, статистику использования heap, в т.ч.:
	3.1 Использование "молодого поколения памяти" (G1 Young Generation)
	3.2 Использование "старого поколения памяти" (G1 Old Generation)

Во время работы приложения можно было отследить, как работает сборщик мусора, при работе программы потребление памяти росло, но в момент, когда срабатывал сборщик, 
количество используемой памяти существенно сокращалось;
Также в начале работы программы G1 Old Generation был не задействован, работать данный сегмент начал через некоторое время, после работы программы.

С помощью добавления строк большой длины удалось достичь ошибка Out of memory exception, и отследить какие параметры heap были достигнуты:
1. Общее время работы программы: 7 минут 48 сек;
2. Количество сборок мусора G1 young generation: 51
3. Количество сборок мусора G1 old generation: 8
4. Время затраченное на сборку мусора G1 young generation: 58мс
5. Время затраченное на сборку мусора G1 young generation: 128мс
Можно сделать вывод, что G1 young generation вызывается намного чаще, и работает меньше времени;
Также видно, что программа заверщила работу, когда память была использована на 89%, из вывода Out of memory exception было видно, 
что была попытка выделить память для массива типа char в классе StringUTF16, но свободной памяти почти не было.